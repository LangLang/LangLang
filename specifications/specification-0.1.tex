\documentclass[a4paper,11pt]{article}

%%%%%%%%%%%%%%%%%%% PACKAGES %%%%%%%%%%%%%%%%%%%
%\usepackage{tikz}
%\usepackage{geometry}
%\geometry{a4paper}
%\usepackage{gcl}
%\usepackage{float}
%\usepackage{wrapfig}
\usepackage{mathtools}
%\usepackage{amsmath}
\usepackage{amssymb}
%\usepackage{amsthm}
\usepackage{proof}


%%%%%%%%%%%%%%%%%%%% MACROS %%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%% DOCUMENT %%%%%%%%%%%%%%%%%%%
\begin{document}

\title{LangLang 0.1}
%\subtitle{Specification}
\author{Rehno Lindeque}

\maketitle

\begin{abstract}
A formal specification of the syntax and semantics for the programming language \textsl{LangLang}.
\end{abstract}
\textbf{Keywords:} \textsl{LangLang}, specification, denotational semantics, operational semantics

\section{Introduction}

\section{Syntax Specification}
\subsection{Formal syntax}

\subsection{Conventions used in this document}
\label{sec:conventions}

Normally \textsl{LangLang}'s syntax dictate that \emph{bottom} should be written as an empty pair of parentheses \texttt{()} to indicate that \emph{bottom} is formally just an empty collection in \textsl{LangLang}.
In this document \emph{bottom} will usually be written using the standard mathematical notation $\bot$.
However, occasionaly the standard syntax for \emph{bottom}, $()$ may be used to emphasize an empty collection.
Similarly \emph{top}, written using an underscore \texttt{\_} in LangLang, corresponds to the mathematical notation $\top$ used in this document.\\

In addition the following conventions are used to indicate the nature of syntactic elements in the semantics.

\begin{description}
  \item[$exs$] A collection of expressions (which may also be, depending on circumstance, $\top$, $\bot$ or a single expression).
  \item[$ex$] A collection consisting of a single expression.
  \item[$(e\ es)$] A collection consisting of the single expression $e$ grouped together with the collection of expression $es$.
  \item[\texttt{t}] A token representing some atom.
\end{description}

\section{Denotational Semantics}

The denotational semantics listed here serve as invariants that inform the design of the operational semantics in the next section.\\

Atoms are the most basic elements in \textsl{LangLang} and are represented by simple whitespace free \emph{tokens} in source code.
In denotational terms two atoms are equal if their token representation is identical.
To facilitate generic programming tokens may also be constructed programmatically, however we delay this topic for later sections.\\

Collections in \textsl{LangLang} do not have any \emph{structure} as all structure is derived using the concept of arrows.
Intuitively this means that collections are fully defined by their contents and have transient ``boundaries'', so to speak.
They cannot be nested in the sense that any collection that contains another collection is indistinguishable from the union of all their elements.
This is unlike the common notion of \emph{sets} in mathematics which includes the set as a basic mathematical object with its own structure.\\

Syntactically, parentheses are used to group things together in \textsl{LangLang}, thus collections may be represented in code by enclosing their contents.
However, as mentioned above, collections' boundaries are transient and disappear when nested.
\[
(ex_0\ (ex_1\ (ex_2\ ex_3))\ ex_4) \quad\triangleq\quad (ex_0\ ex_1\ ex_2\ ex_3\ ex_4)
\]

Furthermore, when a collection contains only a single expression, parentheses may be dropped entirely.
\[
(ex) \quad\triangleq\quad ex
\]

An empty collection $()$ is denoted, in this document, with the symbol $\bot$\footnote{Please take note of the conventions for writing \emph{bottom} mentioned in section \ref{sec:conventions}.}.
\[
() \quad\triangleq\quad \bot
\]

An arrow is an \emph{operational} construct which adds structure to the only other objects in the language, atoms.
As collections are not objects, arrows may not connect to them directly, but instead connect only to their contents.
For this reason, an arrow that connects to an empty collection simply does not exist.
\begin{eqnarray*}
\bot \rightarrow exs \quad&\triangleq&\quad \bot \\
exs \rightarrow \bot \quad&\triangleq&\quad exs \\
(ex_0\ ex_1) \rightarrow ex_2 \quad&\triangleq&\quad (ex_0 \rightarrow ex_2 \quad ex_1 \rightarrow ex_2) \\
ex_0 \rightarrow (ex_1\ ex_2) \quad&\triangleq&\quad (ex_0 \rightarrow ex_1 \quad ex_0 \rightarrow ex_1)
\end{eqnarray*}

Every sub-expression of a larger expression also has the parent expression's context.
However, context is created when an arrow is traversed, hence sub-expressions occuring after one or more arrows will have additional context (once the arrow has been evaluated).

\begin{eqnarray*}
ctx \vdash exs_0 \rightarrow exs_1 \quad&\triangleq&\quad (ctx \vdash exs_0) \rightarrow exs_1 \\
ctx \vdash (exs_0 \rightarrow exs_1) \rightarrow exs_2 \quad&\triangleq&\quad (ctx \vdash exs_0 \rightarrow exs_1) \rightarrow exs_2 \\
                                                            &\triangleq&\quad ((ctx \vdash exs_0) \rightarrow exs_1) \rightarrow exs_2 \\
ctx \vdash exs_0.exs_1 \quad&\triangleq&\quad (ctx \vdash exs_0).exs_1 \\
ctx \vdash exs_0.exs_1.exs_2 \quad&\triangleq&\quad (ctx \vdash exs_0.exs_1).exs_2 \\
                                  &\triangleq&\quad (ctx \vdash exs_0).exs_1.exs_2
\end{eqnarray*}

\section{Operational Semantics}
The rules for evaluating the operational semantics of \textsl{LangLang} expressions are slightly changed from classical natural deduction which uses propositions.
For one thing, we do not attempt to involve propositional statements, rules are purely syntactic in nature.\\
\emph{TODO: The presense of a token \texttt{t} could be interpreted something like a judgement that ``$\exists\mathtt{t}$ in the current context''}\\

In particular, the way that the sequent $\vdash$ is interpreted is quite different from the usual interpretation although it realizes many of the same objectives in spirit.
The sequent is what allows \textsl{LangLang} to perform evaluation in a lazy manner where required\footnote{This also appears to be a (in my humble opinion, fascinating) prerequisite for Turing Completeness in this calculus.}.
The way that the sequent works in the operational semantics is to always move inward to evaluate sub-expressions as can be seen in rules 1.b, 2.2, etc... but after the evaluation is completed, sub-expressions are moved over to the context (and replaced by a newly generated symbol $\lambda$) as in rules 2.1.1 , 2.1.2, 2.3, 2.4 and 2.5\footnote{See also the denotational invariants for contexts, documented earlier.}.

\subsection{Ideal Semantics}
\subsubsection{Rule 1. $ctx \vdash exs$ }
\[
\infer{ctx \vdash \mathtt{t}}{ctx \vdash \mathtt{t}} \eqno{1.1}
\]

\[
\infer{\vdash \top}{ctx \vdash \top} \eqno{1.2}
\]

\[
\infer{\vdash \bot}{ctx \vdash \bot} \eqno{1.a}
\]
(This rule is applied implicitly in the implementation)

\[
\infer{ \left(\dfrac{ctx,es \vdash e}{\vdots}\quad\dfrac{ctx,e \vdash es}{\vdots}\right) }{ ctx \vdash (e\ es) } \eqno{1.b}
\]
Recall from the introduction that the sequent always moves inward.\\
(This rule is applied implicitly in the implementation)

\subsubsection{Rule 2. $ctx \vdash exs_0 \rightarrow exs_1$ }

\[
\infer{ctx \vdash \lambda \rightarrow exs_1}{ctx \vdash (\lambda \rightarrow exs_0) \rightarrow exs_1} \eqno{2.1.1}
\]

Note that the $\lambda$ is never captured inside the context as it is a pseudo-token\footnote{Conceptually $\lambda$ behaves like any regular symbol, thus a new unique symbol could be generated and placed in the context.
Following this conceptual framework, the evaluator would have to have the ability to assign a new unique symbols for each new instance of $\lambda$ it generates automatically - almost a little bit like a turing machine writing to its infinite length tape except that no cell can be destructively updated.}.

\[
\infer{ctx, \mathtt{t}_0 \rightarrow exs_0 \vdash \lambda \rightarrow exs_1}{ctx \vdash (\lambda \mathtt{t}_0 \rightarrow exs_1) \rightarrow exs_1}  \eqno{2.1.2}
\]

This form of the lambda expression is just syntactic sugar, but it is very helpful in some cases.

\[
\infer{\dfrac{\left(\dfrac{ctx \vdash exs_0}{\vdots}\right) \rightarrow exs_1}{\vdots}}{ctx \vdash exs_0 \rightarrow exs_1} \eqno{2.2}
\]
Recall from the introduction that the sequent always moves inward.

\[
\infer{\vdash \bot}{(\vdash \bot) \rightarrow exs_1} \eqno{2.3}
\]

\[
\infer{\vdash \top}{(\vdash \top) \rightarrow exs_1} \eqno{2.4}
\]

\[
\infer{ctx,\mathtt{t}_0 \rightarrow exs_1 \vdash \lambda \rightarrow exs_1}{(ctx \vdash \mathtt{t}_0) \rightarrow exs_1} \eqno{2.5}
\]

\[
\infer{ctx,exs_0,exs_0 \rightarrow exs_1 \vdash \lambda \rightarrow exs_1}{(ctx \vdash exs_0) \rightarrow exs_1} \eqno{2.6}
\]

\subsubsection{Rule 3. $ctx \vdash exs_0.exs_1$ }

\[
\infer{(ctx \vdash exs_0).exs_1}{ctx \vdash exs_0.exs_1} \eqno{3.1.1}
\]
Recall from the introduction that the sequent always moves inward.

\[
\infer{\vdash \bot}{\vdash \bot.exs_1} \eqno{3.1.2}
\]

\[
\infer{\top \vdash \left(\dfrac{ctx \vdash exs}{\vdots}\right)}{ctx \vdash \top.exs_1} \eqno{3.1.2}
\]

\[
\infer{\vdash \bot}{\vdash \mathtt{t}_0.exs_1} \eqno{3.1.3.1}
\]

\[
\infer{\vdash ((\lambda \rightarrow c).(\mathtt{t}_0 \rightarrow \top)).exs_1}{c \vdash \mathtt{t}_0.exs_1} \eqno{3.1.3.2}
\]

\[
\infer{\left(\dfrac{cs \vdash ((\lambda \rightarrow c).(\mathtt{t}_0 \rightarrow \top)).exs_1}{\vdots}\quad\dfrac{cs \vdash \mathtt{t}_0.exs_1}{\vdots}\right)}
{cs,c \vdash \mathtt{t}_0.exs_1} \eqno{3.1.3.3}
\]

\[
\infer{ctx, \mathtt{t}_{0_0} \rightarrow exs_{0_1}\vdash exs_{0_1}}{ctx \vdash (\mathtt{t}_{0_0} \rightarrow exs_{0_1}).\top} \eqno{3.1.4.1.1}
\]
\[
\infer{ctx \vdash exs_{0_1}}{ctx \vdash (\lambda \rightarrow exs_{0_1}).\top} \eqno{3.1.4.1.2}
\]
\[
\infer{ctx \vdash \left(\left(\lambda \rightarrow \dfrac{ctx \vdash exs_{0_{0_0}} \rightarrow exs_{0_{0_1}}}{\vdots}\right).\top \rightarrow exs_{0_1}\right).\top}
{ctx \vdash ((exs_{0_{0_0}} \rightarrow exs_{0_{0_1}}) \rightarrow exs_{0_1}).\top} \eqno{3.1.4.1.3}
\]
\emph{TODO: This is still not correct... need some way to evaluate the first (nested) arrow only once, without going into an infinite loop.}

\[
\infer{\vdots}{ctx \vdash (\lambda \rightarrow exs_{0_1}).exs_1} \eqno{3.1.4.2}
\]
\emph{TODO: Still busy with this one}

\[
\infer{\left(\dfrac{ctx,(e_{0_0}\ e_{0_1}\ \dots\ e_{0_n}) \vdash e_{0_0}.exs_1}{\vdots}\ \dots\ \dfrac{ctx,(e_{0_0}\ e_{0_1}\ \dots\ e_{0_n}) \vdash e_{0_n}.exs_1}{\vdots}\right)}
{ctx \vdash (e_{0_0}\ e_{0_1}\ \dots\ e_{0_n}).exs_1} \eqno{3.1.5}
\]

\emph{TODO: Check rule 3.1.5, there was still some confusion here about evaluation and possible memoization - see the code (it's 3.1.4 in the code at the moment)}

\subsection{Implementation Semantics}

\section{Implementation Details}

\section*{Acknowledgements}

\bibliographystyle{plain}
\bibliography{specification-0.1}

\end{document}
