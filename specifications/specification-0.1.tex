\documentclass[a4paper,11pt]{article}

%%%%%%%%%%%%%%%%%%% PACKAGES %%%%%%%%%%%%%%%%%%%
%\usepackage{tikz}
%\usepackage{geometry}
%\geometry{a4paper}
%\usepackage{gcl}
%\usepackage{float}
%\usepackage{wrapfig}
\usepackage{mathtools}
%\usepackage{amsmath}
\usepackage{amssymb}
%\usepackage{amsthm}
\usepackage{proof}


%%%%%%%%%%%%%%%%%%%% MACROS %%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%% DOCUMENT %%%%%%%%%%%%%%%%%%%
\begin{document}

\title{LangLang 0.1}
%\subtitle{Specification}
\author{Rehno Lindeque}

\maketitle

\begin{abstract}
A formal specification of the syntax and semantics for the programming language \textsl{LangLang}.
\end{abstract}
\textbf{Keywords:} \textsl{LangLang}, specification, denotational semantics, operational semantics

\section{Introduction}

\section{Syntax Specification}
\subsection{Formal syntax}

\subsection{Conventions used in this document}
\label{sec:conventions}

Normally \textsl{LangLang}'s syntax dictate that \emph{bottom} should be written as an empty pair of parentheses \texttt{()} to indicate that \emph{bottom} is formally just an empty collection in \textsl{LangLang}.
In this document \emph{bottom} will usually be written using the standard mathematical notation $\bot$.
However, occasionaly the standard syntax for \emph{bottom}, $()$ may be used to emphasize an empty collection.
Similarly \emph{top}, written using an underscore \texttt{\_} in LangLang, corresponds to the mathematical notation $\top$ used in this document.\\

In addition the following conventions are used to indicate the nature of syntactic elements in the semantics.

\begin{description}
  \item[$exs$] A collection of expressions (which may also be, depending on circumstance, $\top$, $\bot$ or a single expression).
  \item[$ex$] A collection consisting of a single expression.
  \item[$(e\ es)$] A collection consisting of the single expression $e$ grouped together with the collection of expression $es$.
  \item[\texttt{t}] A token representing some atom.
\end{description}

\section{Denotational Semantics}

The denotational semantics listed here serve as invariants that inform the design of the operational semantics in the next section.\\

Atoms are the most basic elements in \textsl{LangLang} and are represented by simple whitespace free \emph{tokens} in source code.
In denotational terms two atoms are equal if their token representation is identical.
To facilitate generic programming tokens may also be constructed programmatically, however we delay this topic for later sections.\\

Collections in \textsl{LangLang} do not have any \emph{structure} as all structure is derived using the concept of arrows.
Intuitively this means that collections are fully defined by their contents and have transient ``boundaries'', so to speak.
They cannot be nested in the sense that any collection that contains another collection is indistinguishable from the union of all their elements.
This is unlike the common notion of \emph{sets} in mathematics which includes the set as a basic mathematical object with its own structure.\\

Syntactically, parentheses are used to group things together in \textsl{LangLang}, thus collections may be represented in code by enclosing their contents.
However, as mentioned above, collections' boundaries are transient and disappear when nested.
\[
(ex0\ (ex1\ (ex2\ ex3))\ ex4) \quad\triangleq\quad (ex0\ ex1\ ex2\ ex3\ ex4)
\]

Furthermore, when a collection contains only a single expression, parentheses may be dropped entirely.
\[
(ex) \quad\triangleq\quad ex
\]

An empty collection $()$ is denoted, in this document, with the symbol $\bot$\footnote{Please take note of the conventions for writing \emph{bottom} mentioned in section \ref{sec:conventions}.}.
\[
() \quad\triangleq\quad \bot
\]

An arrow is an \emph{operational} construct which adds structure to the only other objects in the language, atoms.
As collections are not objects, arrows may not connect to them directly, but instead connect only to their contents.
For this reason, an arrow that connects to an empty collection simply does not exist.
\begin{eqnarray*}
\bot \rightarrow exs \quad&\triangleq&\quad \bot \\
exs \rightarrow \bot \quad&\triangleq&\quad exs \\
(ex0\ ex1) \rightarrow ex2 \quad&\triangleq&\quad (ex0 \rightarrow ex2 \quad ex1 \rightarrow ex2) \\
ex0 \rightarrow (ex1\ ex2) \quad&\triangleq&\quad (ex0 \rightarrow ex1 \quad ex0 \rightarrow ex1)
\end{eqnarray*}

Every sub-expression of a larger expression also has the parent expression's context.
However, context is created when an arrow is traversed, hence sub-expressions occuring after one or more arrows will have additional context.

\begin{eqnarray*}
ctx \vdash exs_0 \rightarrow exs_1 \quad&\triangleq&\quad ctx \vdash (ctx \vdash exs_0) \rightarrow exs_1 \\
ctx \vdash exs_0 \rightarrow exs_1 \quad&\triangleq&\quad ctx \vdash exs_0 \rightarrow (ctx,exs_0,exs_0 \rightarrow exs_1 \vdash exs_1)
\end{eqnarray*}

\emph{TODO: Check this second rule for correctness. 
Should $exs_0$ and $exs_0 \rightarrow exs_1$ be evaluated before they can be added to the context of $exs_1$.
This is rather hard to intuit and needs some thought.}

\section{Operational Semantics}
The rules for evaluating the operational semantics of \textsl{LangLang} expressions are slightly changed from classical natural deduction which uses propositions.
For one thing, we do not attempt to involve propositional statements, rules are purely syntactic in nature.\\
\emph{TODO: The presense of a token \texttt{t} could be interpreted something like a judgement that ``$\exists\mathtt{t}$ in the current context''}\\

In particular, the way that the sequent $\vdash$ is interpreted is quite different from the usual interpretation although it realizes many of the same objectives in spirit.
The sequent is what allows \textsl{LangLang} to perform evaluation in a lazy manner where required\footnote{This also appears to be a (in my humble opinion, fascinating) prerequisite for Turing Completeness in this calculus.}.\\
\emph{TODO: Elaborate on this...}

\subsection{Ideal Semantics}
\subsubsection{Rule 1. $ctx \vdash exs$ }
\[
\infer{ctx \vdash \mathtt{t}}{ctx \vdash \mathtt{t}} \eqno{1.1}
\]

\[
\infer{\vdash \top}{ctx \vdash \top} \eqno{1.2}
\]

\[
\infer{\vdash \bot}{ctx \vdash \bot} \eqno{1.a}
\]
(This rule is applied implicitly in the implementation)

\[
\infer{ \left(\dfrac{ctx \vdash e}{\vdots}\quad\dfrac{ctx \vdash es}{\vdots}\right) }{ ctx \vdash (e\ es) } \eqno{1.b}
\]
(This rule is applied implicitly in the implementation)

\subsubsection{Rule 2. $ctx \vdash exs_0 \rightarrow exs_1$ }
\[
\infer{\vdash \bot}{ctx \vdash \bot \rightarrow exs_1} \eqno{2.1.1}
\]

\[
\infer{\vdash \top}{ctx \vdash \top \rightarrow exs_1} \eqno{2.1.2}
\]

\[
\infer{ctx \vdash \lambda \rightarrow exs_1}{ctx \vdash \lambda \rightarrow exs_1} \eqno{2.1.3}
\]
\begin{equation*}
\infer{ctx \vdash \lambda \mathtt{t}_0 \rightarrow exs_1}{ctx \vdash \lambda \mathtt{t}_0 \rightarrow exs_1}
\end{equation*}

\[
\infer{ctx \vdash exs_0 \rightarrow exs_1}{ctx \vdash \left(ctx \vdash exs_0\right) \rightarrow exs_1} \eqno{2.1.4}
\]

\[
\infer{ctx \vdash \left(\dfrac{ctx \vdash exs_0}{\vdots}\right) \rightarrow exs_1}{ctx \vdash exs_0 \rightarrow exs_1} \eqno{2.1.5}
\]
Rule 2.1.5 implicitly matches all of the following premises:
\begin{eqnarray*}
ctx \vdash t_0 \rightarrow exs_1\\
ctx \vdash (e_0 es_0) \rightarrow exs_1\\
ctx \vdash (\lambda \rightarrow exs_{0_1}) \rightarrow exs_1\\
ctx \vdash (\lambda \mathtt{t}_{0_0} \rightarrow exs_{0_1}) \rightarrow exs_1\\
ctx \vdash (exs_{0_0} \rightarrow exs_{0_1}) \rightarrow exs_1\\
ctx \vdash exs_{0_0} . exs_{0_1}  \rightarrow exs_1
\end{eqnarray*}

\[
\infer{ctx \vdash exs_1}{ctx \vdash exs_0 \rightarrow \bot} \eqno{2.2.1}
\]

\[
\infer{ctx \vdash exs_0 \rightarrow \left(\dfrac{ctx \vdash exs_{1_0} . exs_{1_1}}{\vdots}\right)}{ctx \vdash exs_0 \rightarrow exs_{1_0} . exs_{1_1}} \eqno{2.2.?}
\]
\emph{TODO: check this}

\[
\infer{ctx \vdash exs_0 \rightarrow exs_1}{ctx \vdash exs_0 \rightarrow exs_1} \eqno{2.2.?}
\]

Catch all remaining premises:
\emph{TODO}\\\\


\emph{ALSO, what about this? Is there some kind of rule for inner context to disappear? }
\[
ctx \vdash exs_0 \rightarrow (ctx_0 \vdash exs_1)
\]


\subsection{Implementation Semantics}

\section{Implementation Details}

\section*{Acknowledgements}

\bibliographystyle{plain}
\bibliography{specification-0.1}

\end{document}
